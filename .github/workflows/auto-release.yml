name: Auto Release & Publish

# Automatically bump patch version, tag, and publish to PyPI
# on every push to main that changes source code or tests.
# Commits with [auto-release] or [skip release] in message are skipped.

on:
  push:
    branches: [main]
    paths:
      - "infomesh/**"
      - "tests/**"
      - "pyproject.toml"
      - "seeds/**"
      - "bootstrap/**"
      - ".github/workflows/auto-release.yml"
  workflow_dispatch:

concurrency:
  group: auto-release
  cancel-in-progress: false

permissions:
  contents: write
  id-token: write

jobs:
  test:
    runs-on: ubuntu-latest
    if: >-
      !contains(github.event.head_commit.message, '[auto-release]') &&
      !contains(github.event.head_commit.message, '[skip release]')
    steps:
      - uses: actions/checkout@v4

      - name: Install uv
        uses: astral-sh/setup-uv@v4
        with:
          version: "latest"

      - name: Set up Python
        run: uv python install 3.12

      - name: Install dependencies
        run: uv sync --dev

      - name: Lint
        run: uv run ruff check infomesh/ tests/

      - name: Run tests
        run: |
          uv run pytest tests/ \
            --ignore=tests/test_vector.py \
            --ignore=tests/test_libp2p_spike.py \
            -x -q --tb=short

  publish:
    needs: test
    runs-on: ubuntu-latest
    environment: pypi
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install uv
        uses: astral-sh/setup-uv@v4
        with:
          version: "latest"

      - name: Set up Python
        run: uv python install 3.12

      - name: Determine next version
        id: version
        run: |
          # Use REMOTE tags to avoid stale local tag state after fresh CI checkout
          latest_tag=$(
            git ls-remote --tags origin 'refs/tags/v*' \
              | sed 's|.*refs/tags/||' \
              | sort -V \
              | tail -n1
          )
          if [ -z "$latest_tag" ]; then
            latest_tag="v0.1.0"
          fi
          echo "Latest tag (from remote): $latest_tag"

          # Parse major.minor.patch
          version_str="${latest_tag#v}"
          IFS='.' read -r major minor patch <<< "$version_str"

          # Bump patch
          patch=$((patch + 1))
          new_version="${major}.${minor}.${patch}"
          new_tag="v${new_version}"

          # Check if tag already exists on REMOTE
          if git ls-remote --tags origin "refs/tags/${new_tag}" | grep -q "$new_tag"; then
            echo "âš ï¸ Tag $new_tag already exists on remote â€” skipping release"
            echo "skip=true" >> "$GITHUB_OUTPUT"
          else
            echo "skip=false" >> "$GITHUB_OUTPUT"
          fi

          echo "version=${new_version}" >> "$GITHUB_OUTPUT"
          echo "tag=${new_tag}" >> "$GITHUB_OUTPUT"
          echo "Next version: ${new_version}"

      - name: Update version in pyproject.toml
        if: steps.version.outputs.skip != 'true'
        run: |
          sed -i 's/^version = ".*"/version = "${{ steps.version.outputs.version }}"/' pyproject.toml
          echo "Updated pyproject.toml:"
          head -5 pyproject.toml

      - name: Update version in __init__.py
        if: steps.version.outputs.skip != 'true'
        run: |
          sed -i 's/^__version__ = ".*"/__version__ = "${{ steps.version.outputs.version }}"/' infomesh/__init__.py
          echo "Updated __init__.py:"
          grep __version__ infomesh/__init__.py

      - name: Generate release notes from commits
        if: steps.version.outputs.skip != 'true'
        id: notes
        run: |
          # Use REMOTE tags for consistency (local checkout may be stale)
          # This must run BEFORE the version bump commit, while HEAD is still
          # the developer's last real commit.
          latest_tag=$(
            git ls-remote --tags origin 'refs/tags/v*' \
              | sed 's|.*refs/tags/||' \
              | sort -V \
              | tail -n1
          )
          if [ -z "$latest_tag" ]; then
            range="HEAD"
          else
            range="${latest_tag}..HEAD"
          fi
          echo "Generating release notes for range: ${range}"

          # Categorize commits by conventional-commit prefix
          features=""
          fixes=""
          docs=""
          chores=""
          tests=""
          others=""

          while IFS= read -r line; do
            # Skip auto-release commits, skip-release commits, and empty lines
            if [ -z "$line" ] || echo "$line" | grep -qE '\[(auto-release|skip release)\]'; then
              continue
            fi
            # Categorize by conventional-commit prefix
            if echo "$line" | grep -qi '^feat'; then
              msg=$(echo "$line" | sed -E 's/^feat([(][^)]*[)])?[[:space:]]*:[[:space:]]*//')
              features="${features}- ${msg}\n"
            elif echo "$line" | grep -qi '^fix'; then
              msg=$(echo "$line" | sed -E 's/^fix([(][^)]*[)])?[[:space:]]*:[[:space:]]*//')
              fixes="${fixes}- ${msg}\n"
            elif echo "$line" | grep -qi '^docs'; then
              msg=$(echo "$line" | sed -E 's/^docs([(][^)]*[)])?[[:space:]]*:[[:space:]]*//')
              docs="${docs}- ${msg}\n"
            elif echo "$line" | grep -qi '^test'; then
              msg=$(echo "$line" | sed -E 's/^test([(][^)]*[)])?[[:space:]]*:[[:space:]]*//')
              tests="${tests}- ${msg}\n"
            elif echo "$line" | grep -qi '^chore'; then
              msg=$(echo "$line" | sed -E 's/^chore([(][^)]*[)])?[[:space:]]*:[[:space:]]*//')
              chores="${chores}- ${msg}\n"
            elif echo "$line" | grep -qi '^refactor\|^perf\|^ci\|^build\|^style'; then
              msg=$(echo "$line" | sed -E 's/^(refactor|perf|ci|build|style)([(][^)]*[)])?[[:space:]]*:[[:space:]]*//')
              chores="${chores}- ${msg}\n"
            else
              # Non-conventional commits â€” classify by keywords in the message
              lower=$(echo "$line" | tr '[:upper:]' '[:lower:]')
              if echo "$lower" | grep -qE 'add|implement|support|enable|new|create|introduce'; then
                features="${features}- ${line}\n"
              elif echo "$lower" | grep -qE 'fix|patch|correct|resolve|repair|bug'; then
                fixes="${fixes}- ${line}\n"
              elif echo "$lower" | grep -qE 'doc|readme|changelog|comment|typo'; then
                docs="${docs}- ${line}\n"
              elif echo "$lower" | grep -qE 'test|spec|coverage|assert'; then
                tests="${tests}- ${line}\n"
              else
                others="${others}- ${line}\n"
              fi
            fi
          done <<< "$(git log "${range}" --pretty=format:'%s' --no-merges)"

          # Build release body
          body=""
          if [ -n "$features" ]; then
            body="${body}## ðŸš€ New Features\n${features}\n"
          fi
          if [ -n "$fixes" ]; then
            body="${body}## ðŸ› Bug Fixes\n${fixes}\n"
          fi
          if [ -n "$docs" ]; then
            body="${body}## ðŸ“– Documentation\n${docs}\n"
          fi
          if [ -n "$tests" ]; then
            body="${body}## ðŸ§ª Tests\n${tests}\n"
          fi
          if [ -n "$chores" ]; then
            body="${body}## ðŸ”§ Maintenance\n${chores}\n"
          fi
          if [ -n "$others" ]; then
            body="${body}## ðŸ”„ Other Changes\n${others}\n"
          fi

          # If no categorized commits, fall back to auto-generated
          if [ -z "$body" ]; then
            echo "use_generate=true" >> "$GITHUB_OUTPUT"
          else
            # Write to file (handles multiline safely)
            printf '%b' "$body" > /tmp/release-notes.md
            echo "use_generate=false" >> "$GITHUB_OUTPUT"
            echo "--- Generated release notes ---"
            cat /tmp/release-notes.md
          fi

      - name: Build package
        if: steps.version.outputs.skip != 'true'
        run: uv build

      - name: Verify package
        if: steps.version.outputs.skip != 'true'
        run: |
          ls -la dist/
          # Ensure the built package has correct version
          ls dist/ | grep "${{ steps.version.outputs.version }}"

      - name: Commit version bump & create tag
        if: steps.version.outputs.skip != 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add pyproject.toml infomesh/__init__.py
          # Only commit if there are staged changes (version may already be bumped)
          if git diff --cached --quiet; then
            echo "Version files already at target â€” skipping commit"
          else
            git commit -m "chore: release v${{ steps.version.outputs.version }} [auto-release]"
          fi
          # Force-create tag (may already exist locally from a previous failed run)
          git tag -f "${{ steps.version.outputs.tag }}"
          # Push commit (if any) â€” continue even if already up-to-date
          git push origin main --follow-tags || true
          # Explicitly push the tag (handles case where --follow-tags silently skips)
          git push origin "${{ steps.version.outputs.tag }}" --force

      - name: Create GitHub Release
        if: steps.version.outputs.skip != 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Skip if release already exists (e.g., from a partial retry)
          if gh release view "${{ steps.version.outputs.tag }}" &>/dev/null; then
            echo "Release ${{ steps.version.outputs.tag }} already exists â€” skipping"
          elif [ "${{ steps.notes.outputs.use_generate }}" = "true" ]; then
            gh release create "${{ steps.version.outputs.tag }}" \
              dist/* \
              --title "v${{ steps.version.outputs.version }}" \
              --target "${{ github.sha }}" \
              --generate-notes
          else
            gh release create "${{ steps.version.outputs.tag }}" \
              dist/* \
              --title "v${{ steps.version.outputs.version }}" \
              --target "${{ github.sha }}" \
              --notes-file /tmp/release-notes.md
          fi

      - name: Publish to PyPI
        if: steps.version.outputs.skip != 'true'
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          skip-existing: true
