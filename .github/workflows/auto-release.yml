name: Auto Release & Publish

# Automatically bump patch version, tag, and publish to PyPI
# on every push to main that changes source code or tests.
# Commits with [auto-release] or [skip release] in message are skipped.

on:
  push:
    branches: [main]
    paths:
      - "infomesh/**"
      - "tests/**"
      - "pyproject.toml"
      - "seeds/**"
      - "bootstrap/**"
      - ".github/workflows/auto-release.yml"
  workflow_dispatch:

concurrency:
  group: auto-release
  cancel-in-progress: false

permissions:
  contents: write
  id-token: write

jobs:
  test:
    runs-on: ubuntu-latest
    if: >-
      !contains(github.event.head_commit.message, '[auto-release]') &&
      !contains(github.event.head_commit.message, '[skip release]')
    steps:
      - uses: actions/checkout@v4

      - name: Install uv
        uses: astral-sh/setup-uv@v4
        with:
          version: "latest"

      - name: Set up Python
        run: uv python install 3.12

      - name: Install dependencies
        run: uv sync --dev

      - name: Lint
        run: uv run ruff check infomesh/ tests/

      - name: Run tests
        run: |
          uv run pytest tests/ \
            --ignore=tests/test_vector.py \
            --ignore=tests/test_libp2p_spike.py \
            -x -q --tb=short

  publish:
    needs: test
    runs-on: ubuntu-latest
    environment: pypi
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install uv
        uses: astral-sh/setup-uv@v4
        with:
          version: "latest"

      - name: Set up Python
        run: uv python install 3.12

      - name: Determine next version
        id: version
        run: |
          # Get the highest semver tag across ALL tags (not just reachable from HEAD)
          latest_tag=$(git tag -l 'v*' | sort -V | tail -n1)
          if [ -z "$latest_tag" ]; then
            latest_tag="v0.1.0"
          fi
          echo "Latest tag: $latest_tag"

          # Parse major.minor.patch
          version_str="${latest_tag#v}"
          IFS='.' read -r major minor patch <<< "$version_str"

          # Bump patch
          patch=$((patch + 1))
          new_version="${major}.${minor}.${patch}"
          new_tag="v${new_version}"

          # Check if tag already exists on REMOTE (local may not have it after fresh checkout)
          if git ls-remote --tags origin "$new_tag" | grep -q "$new_tag"; then
            echo "âš ï¸ Tag $new_tag already exists on remote â€” skipping release"
            echo "skip=true" >> "$GITHUB_OUTPUT"
          else
            echo "skip=false" >> "$GITHUB_OUTPUT"
          fi

          echo "version=${new_version}" >> "$GITHUB_OUTPUT"
          echo "tag=${new_tag}" >> "$GITHUB_OUTPUT"
          echo "Next version: ${new_version}"

      - name: Update version in pyproject.toml
        if: steps.version.outputs.skip != 'true'
        run: |
          sed -i 's/^version = ".*"/version = "${{ steps.version.outputs.version }}"/' pyproject.toml
          echo "Updated pyproject.toml:"
          head -5 pyproject.toml

      - name: Update version in __init__.py
        if: steps.version.outputs.skip != 'true'
        run: |
          sed -i 's/^__version__ = ".*"/__version__ = "${{ steps.version.outputs.version }}"/' infomesh/__init__.py
          echo "Updated __init__.py:"
          grep __version__ infomesh/__init__.py

      - name: Build package
        if: steps.version.outputs.skip != 'true'
        run: uv build

      - name: Verify package
        if: steps.version.outputs.skip != 'true'
        run: |
          ls -la dist/
          # Ensure the built package has correct version
          ls dist/ | grep "${{ steps.version.outputs.version }}"

      - name: Commit version bump & create tag
        if: steps.version.outputs.skip != 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add pyproject.toml infomesh/__init__.py
          # Only commit if there are staged changes (version may already be bumped)
          if git diff --cached --quiet; then
            echo "Version files already at target â€” skipping commit"
          else
            git commit -m "chore: release v${{ steps.version.outputs.version }} [auto-release]"
          fi
          # Force-create tag (may already exist locally from a previous failed run)
          git tag -f "${{ steps.version.outputs.tag }}"
          git push origin main --follow-tags

      - name: Generate release notes from commits
        if: steps.version.outputs.skip != 'true'
        id: notes
        run: |
          # Get previous tag
          prev_tag=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")

          if [ -z "$prev_tag" ]; then
            range="HEAD"
          else
            range="${prev_tag}..HEAD"
          fi

          # Categorize commits by conventional-commit prefix
          features=""
          fixes=""
          docs=""
          others=""

          while IFS= read -r line; do
            # Skip auto-release commits and empty lines
            if [ -z "$line" ] || echo "$line" | grep -q '\[auto-release\]'; then
              continue
            fi
            # Strip conventional-commit prefix: feat(scope): msg â†’ msg
            if echo "$line" | grep -qi '^feat'; then
              msg=$(echo "$line" | sed -E 's/^feat([(][^)]*[)])?[[:space:]]*:[[:space:]]*//')
              features="${features}- ${msg}\n"
            elif echo "$line" | grep -qi '^fix'; then
              msg=$(echo "$line" | sed -E 's/^fix([(][^)]*[)])?[[:space:]]*:[[:space:]]*//')
              fixes="${fixes}- ${msg}\n"
            elif echo "$line" | grep -qi '^docs'; then
              msg=$(echo "$line" | sed -E 's/^docs([(][^)]*[)])?[[:space:]]*:[[:space:]]*//')
              docs="${docs}- ${msg}\n"
            else
              others="${others}- ${line}\n"
            fi
          done <<< "$(git log "${range}" --pretty=format:'%s' --no-merges)"

          # Build release body
          body=""
          if [ -n "$features" ]; then
            body="${body}## ðŸš€ New Features\n${features}\n"
          fi
          if [ -n "$fixes" ]; then
            body="${body}## ðŸ› Bug Fixes\n${fixes}\n"
          fi
          if [ -n "$docs" ]; then
            body="${body}## ðŸ“– Documentation\n${docs}\n"
          fi
          if [ -n "$others" ]; then
            body="${body}## ðŸ”„ Other Changes\n${others}\n"
          fi

          # If no categorized commits, fall back to auto-generated
          if [ -z "$body" ]; then
            echo "use_generate=true" >> "$GITHUB_OUTPUT"
          else
            # Write to file (handles multiline safely)
            printf '%b' "$body" > /tmp/release-notes.md
            echo "use_generate=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Create GitHub Release
        if: steps.version.outputs.skip != 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          if [ "${{ steps.notes.outputs.use_generate }}" = "true" ]; then
            gh release create "${{ steps.version.outputs.tag }}" \
              dist/* \
              --title "v${{ steps.version.outputs.version }}" \
              --generate-notes
          else
            gh release create "${{ steps.version.outputs.tag }}" \
              dist/* \
              --title "v${{ steps.version.outputs.version }}" \
              --notes-file /tmp/release-notes.md
          fi

      - name: Publish to PyPI
        if: steps.version.outputs.skip != 'true'
        uses: pypa/gh-action-pypi-publish@release/v1
